import fs from 'fs';
import path from 'path';
import { calculateRiskScore, makeDecision, type TenantData } from '../src/lib/screening';
import { defaultScreeningConfig } from '../src/lib/screeningConfig';

interface HistoricalApplicant extends TenantData {
  id: string;
  proxy_group: string;
  tenancy_outcome: 'successful' | 'unsuccessful';
  actual_outcome: 'approved' | 'flagged' | 'denied';
}

interface OutcomeSummary {
  screened: number;
  approvals: number;
  denials: number;
  flagged: number;
  falsePositives: number;
  falseNegatives: number;
  reviewCatches: number;
}

function initialiseSummary(): OutcomeSummary {
  return {
    screened: 0,
    approvals: 0,
    denials: 0,
    flagged: 0,
    falsePositives: 0,
    falseNegatives: 0,
    reviewCatches: 0,
  };
}

function monitor(applicants: HistoricalApplicant[]) {
  const config = defaultScreeningConfig;
  const overall = initialiseSummary();
  const byGroup = new Map<string, OutcomeSummary>();

  for (const applicant of applicants) {
    const risk = calculateRiskScore(applicant, config);
    const decision = makeDecision(risk, config);

    const summary = byGroup.get(applicant.proxy_group) ?? initialiseSummary();
    summary.screened += 1;
    overall.screened += 1;

    if (decision === 'Approved') {
      summary.approvals += 1;
      overall.approvals += 1;
      if (applicant.tenancy_outcome === 'unsuccessful') {
        summary.falsePositives += 1;
        overall.falsePositives += 1;
      }
    } else if (decision === 'Denied') {
      summary.denials += 1;
      overall.denials += 1;
      if (applicant.tenancy_outcome === 'successful') {
        summary.falseNegatives += 1;
        overall.falseNegatives += 1;
      }
    } else {
      summary.flagged += 1;
      overall.flagged += 1;
      if (applicant.tenancy_outcome === 'unsuccessful') {
        summary.reviewCatches += 1;
        overall.reviewCatches += 1;
      }
    }

    byGroup.set(applicant.proxy_group, summary);
  }

  return { overall, byGroup };
}

function buildReport(overall: OutcomeSummary, byGroup: Map<string, OutcomeSummary>): string {
  const lines: string[] = [];

  const falsePositiveRate = overall.approvals === 0 ? 0 : overall.falsePositives / overall.approvals;
  const falseNegativeRate = overall.denials === 0 ? 0 : overall.falseNegatives / overall.denials;

  lines.push('# Acceptance Monitoring Dashboard');
  lines.push('');
  lines.push(
    `Reviewed ${overall.screened} validation tenancies with qualitative features integrated into scoring. False approval rate: ${(falsePositiveRate * 100).toFixed(1)}%, false denial rate: ${(falseNegativeRate * 100).toFixed(1)}%.`,
  );
  lines.push('');

  lines.push('## Outcome distribution by proxy group');
  lines.push('');
  lines.push('| Proxy Group | Screened | Approved | Flagged | Denied | False Approvals | False Denials | Manual Review Saves |');
  lines.push('| --- | ---: | ---: | ---: | ---: | ---: | ---: | ---: |');
  for (const [group, summary] of Array.from(byGroup.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
    lines.push(
      `| ${group} | ${summary.screened} | ${summary.approvals} | ${summary.flagged} | ${summary.denials} | ${summary.falsePositives} | ${summary.falseNegatives} | ${summary.reviewCatches} |`,
    );
  }
  lines.push('');

  lines.push('## Threshold tuning guidance');
  lines.push('');
  if (overall.falseNegatives > overall.falsePositives) {
    lines.push(
      `- False denials (${overall.falseNegatives}) exceed false approvals (${overall.falsePositives}). Consider increasing the approval threshold slightly (e.g. +0.25 risk tolerance) to prevent successful tenants from being declined automatically.`,
    );
  } else if (overall.falsePositives > overall.falseNegatives) {
    lines.push(
      `- False approvals (${overall.falsePositives}) exceed false denials (${overall.falseNegatives}). Consider tightening the approval threshold or raising the review threshold to route more marginal cases for human review.`,
    );
  } else {
    lines.push('- False approvals and denials are balanced. Maintain current thresholds while continuing to monitor monthly.');
  }

  lines.push(
    `- Manual review has intercepted ${overall.reviewCatches} unsuccessful tenancies. Ensure reviewers prioritise these cases to maintain low loss rates.`,
  );

  lines.push('');
  lines.push('_Report generated by scripts/monitorAcceptance.ts._');
  lines.push('');

  return lines.join('\n');
}

function main() {
  const dataPath = path.join(__dirname, '..', 'data', 'historical_applicants.json');
  const reportPath = path.join(__dirname, '..', 'analysis', 'acceptance_monitoring.md');

  const raw = fs.readFileSync(dataPath, 'utf-8');
  const applicants = JSON.parse(raw) as HistoricalApplicant[];

  const { overall, byGroup } = monitor(applicants);
  const report = buildReport(overall, byGroup);
  fs.writeFileSync(reportPath, report, 'utf-8');

  console.log(`Monitoring snapshot written to ${reportPath}`);
}

main();
